# Задача 1
## Области для улучшения и потенциальные проблемы производительности в скрипте:

1.  **Непоследовательные соглашения об именовании:**

    *   Необходимо стандартизировать соглашения об именовании. В скрипте используется смесь стилей (например, Id_Employee, ID_ORGANIZATION, IS_Complit, StatusId, TemlateVal). Требуется выбрать единый стиль (например, PascalCase, camelCase или с подчеркиваниями) и последовательно применять его ко всем объектам базы данных. Стоит так же уделить внимание информативности названий. 
2.  **Функция F_EMPLOYEE_GET():**

    *   Функция F_EMPLOYEE_GET() ненадежно определяет текущего пользователя, полагаясь на SYSTEM_USER. Следует изменить логику, чтобы получать ID сотрудника более надежным способом, например, передавая его как параметр или используя CONTEXT_INFO.

3.  **Неявное преобразование:**

    *   Столбец D_DATE в таблице @RESULT определен как VARCHAR(10), но CREATE_Date (DATETIME) из таблицы Works преобразуется в VARCHAR с использованием стиля 104. Следует изменить тип данных столбца D_DATE на DATETIME или использовать явное преобразование с указанием стиля, чтобы избежать потенциальных проблем с производительностью.

4.  **Вычисляемый столбец FULL_NAME в таблице Employee:**

    *   Вычисляемый столбец FULL_NAME в таблице Employee может снижать производительность запросов. Рассмотреть возможность создания индекса на этом столбце, если он часто используется в предложениях WHERE или ORDER BY.

5.  **Расчет столбца Is_Print:**

    *   Логика определения столбца Is_Print в функции F_WORKS_LIST слишком сложная. Необходимо упростить это условие, чтобы повысить читаемость и потенциально улучшить производительность. Кроме того, имя Is_Print вводит в заблуждение, так как проверяет несколько дат "SendTo", а не только дату печати.

6.  **WHERE WORKS.IS_DEL <> 1:**

    *   Для оптимизации запросов, использующих фильтрацию WORKS.IS_DEL <> 1, необходимо создать индекс на столбце IS_DEL.

7.  **Неэффективность NOT IN:**

    *   В функции F_WORKITEMS_COUNT_BY_ID_WORK используется конструкция NOT IN (SELECT id_analiz FROM analiz WHERE is_group = 1). Требуется заменить NOT IN на NOT EXISTS или LEFT JOIN ... WHERE ... IS NULL для повышения производительности.

8.  **LEFT OUTER JOIN WorkStatus:**

    *   Функция F_WORKS_LIST использует LEFT OUTER JOIN WorkStatus, это означает, что Works.StatusId может быть NULL. Необходимо предусмотреть обработку этого случая.

# Задача 2
## Перед изменением функций стоит удалить существующие, чтобы не возникало конфликтов.
```
DROP FUNCTION IF EXISTS dbo.F_WORKITEMS_COUNT_BY_ID_WORK;
GO

DROP FUNCTION IF EXISTS dbo.F_EMPLOYEE_FULLNAME;
GO

DROP FUNCTION IF EXISTS dbo.F_WORKS_LIST;
GO
```

## Предлагаемые изменения:

*   **`F_WORKITEMS_COUNT_BY_ID_WORK()`**:

    *   Заменить `NOT IN` на `NOT EXISTS`.
    *   Сделать функцию inline table-valued function (iTVF) для лучшей оптимизации. Это позволит SQL Server более эффективно использовать индексы.

    ```
	CREATE OR ALTER FUNCTION dbo.F_WORKITEMS_COUNT_BY_ID_WORK (
		@id_work INT,
		@is_complit BIT
	)
	RETURNS TABLE
	AS
	RETURN
	(
		SELECT COUNT(*) AS Count
		FROM WorkItem wi
		WHERE wi.id_work = @id_work
		  AND wi.is_complit = @is_complit
		  AND NOT EXISTS (
			  SELECT 1 FROM Analiz a WHERE a.id_analiz = wi.id_analiz AND a.is_group = 1
		  )
	);
	GO
    ```

*   **`F_EMPLOYEE_FULLNAME()`**:

    *   Сделать функцию iTVF.
    *   Избегать конкатенации строк для формирования `FULL_NAME`.
    *   Не использовать `LOGIN_NAME`, создать индекс на `SURNAME`, `NAME`, `PATRONYMIC`.

    ```
	CREATE OR ALTER FUNCTION dbo.F_EMPLOYEE_FULLNAME (@ID_EMPLOYEE INT)
	RETURNS TABLE
	AS
	RETURN
	(
		SELECT
			CASE
				WHEN e.Id_Employee IS NULL THEN ''
				ELSE RTRIM(e.Surname + ' ' + LEFT(e.Name, 1) + '. ' + LEFT(e.Patronymic, 1) + '.')
			END AS FullName
		FROM Employee e
		WHERE e.Id_Employee = @ID_EMPLOYEE
	);
	GO
    ```

*   **`F_WORKS_LIST()`**:
    *   Заменить вызовы скалярных функций `F_WORKITEMS_COUNT_BY_ID_WORK` и `F_EMPLOYEE_FULLNAME` на `OUTER APPLY`.

    ```
	CREATE OR ALTER FUNCTION dbo.F_WORKS_LIST()
	RETURNS @RESULT TABLE
	(
		ID_WORK INT,
		CREATE_Date DATETIME,
		MaterialNumber DECIMAL(8,2),
		IS_Complit BIT,
		FIO VARCHAR(255),
		D_DATE VARCHAR(10),
		WorkItemsNotComplit INT,
		WorkItemsComplit INT,
		FULL_NAME VARCHAR(101),
		StatusId SMALLINT,
		StatusName VARCHAR(255),
		Is_Print BIT
	)
	AS
	BEGIN
		INSERT INTO @RESULT
		SELECT
			w.Id_Work,
			w.CREATE_Date,
			w.MaterialNumber,
			w.IS_Complit,
			w.FIO,
			CONVERT(VARCHAR(10), w.CREATE_Date, 104) AS D_DATE,
			wi_not_complit.Count AS WorkItemsNotComplit,
			wi_complit.Count AS WorkItemsComplit,
			ef.FullName,
			w.StatusId,
			ws.StatusName,
			CASE
				WHEN w.Print_Date IS NOT NULL
				  OR w.SendToClientDate IS NOT NULL
				  OR w.SendToDoctorDate IS NOT NULL
				  OR w.SendToOrgDate IS NOT NULL
				  OR w.SendToFax IS NOT NULL THEN 1
				ELSE 0
			END AS Is_Print
		FROM Works w
		LEFT JOIN WorkStatus ws ON w.StatusId = ws.StatusID
		OUTER APPLY dbo.F_WORKITEMS_COUNT_BY_ID_WORK(w.Id_Work, 0) wi_not_complit
		OUTER APPLY dbo.F_WORKITEMS_COUNT_BY_ID_WORK(w.Id_Work, 1) wi_complit
		OUTER APPLY dbo.F_EMPLOYEE_FULLNAME(w.Id_Employee) ef
		WHERE w.IS_DEL <> 1
		ORDER BY w.Id_Work DESC;

		RETURN;
	END;
	GO
    ```

# Задача 3
## Предлагаемые изменения

### 1. Создание новых таблиц (например, кэш-таблиц или агрегированных данных)

- **Описание:**  
  Создать отдельную таблицу (например, `Works_Cache`), в которой заранее будут храниться агрегированные данные по заказам и их элементам (например, количество готовых и неготовых элементов, суммарная цена и т.п.). Запрос будет обращаться к этой таблице, что значительно ускорит выборку.

- **Недостатки и последствия:**  
  - **Рассинхронизация данных:** Данные в кэш-таблице могут устаревать, если обновления в исходных таблицах происходят не мгновенно. Требуются механизмы синхронизации (триггеры, процедуры), которые усложняют архитектуру.  
  - **Увеличение объема данных:** Дублирование информации увеличивает размер базы и нагрузку на хранение.  
  - **Сложность поддержки:** Необходимость поддержки логики обновления кэша, особенно при сложных бизнес-правилах.  
  - **Потенциальное замедление операций записи:** Обновление кэш-таблиц при вставках/обновлениях в основных таблицах может замедлить транзакции.

---
### 2. Создание индексов на поля `IS_DEL`, `IS_GROUP` и `IS_COMPLIT`

- **Описание:**  
  Создать некластеризованные индексы на следующих полях для ускорения фильтрации и повышения производительности запросов:  
  - `Works.IS_DEL` — для быстрого исключения удалённых заказов из выборки.  
  - `Analiz.IS_GROUP` — для оптимизации подзапросов, исключающих групповые анализы.  
  - `WorkItem.IS_COMPLIT` — для ускорения подсчёта готовых и неготовых элементов заказа.

- **Недостатки и последствия:**  
  - **Замедление операций записи:** При вставках, обновлениях и удалениях в таблицах `Works`, `Analiz` и `WorkItem` потребуется обновлять соответствующие индексы, что увеличит время выполнения транзакций.  
  - **Увеличение занимаемого пространства:** Индексы занимают дополнительное дисковое пространство, что особенно заметно при больших объёмах данных (например, 50 000 заказов и связанные с ними элементы).  
  - **Повышенная нагрузка на обслуживание:** Индексы требуют регулярного обновления статистики и периодической перестройки для поддержания эффективности.  
  - **Возможные блокировки и конкуренция:** Создание и обновление индексов может приводить к блокировкам на уровне таблиц или страниц, что снижает параллелизм и может вызвать задержки при массовых операциях.  
  - **Риск избыточного индексирования:** Без тщательного анализа индексы на этих полях могут быть неэффективными или избыточными, что ухудшит общую производительность системы.

---

### 3. Добавление новых столбцов (например, для кэширования вычисляемых значений)

- **Описание:**  
  Добавить в таблицу `Works` столбец, например, `TotalPrice` или `WorkItemsCount`, который будет хранить заранее подсчитанные значения, чтобы не выполнять сложные подсчёты в запросах.

- **Недостатки и последствия:**  
  - **Избыточность и риск рассинхронизации:** Значения нужно поддерживать в актуальном состоянии через триггеры или процедуры, что усложняет логику и может привести к ошибкам.  
  - **Увеличение размера таблицы:** Дополнительные столбцы увеличивают размер строк и общий объем данных.  
  - **Дополнительная нагрузка на операции записи:** Обновления и вставки будут медленнее из-за необходимости пересчёта и обновления кэшированных значений.

---

### 4. Создание триггеров для автоматического обновления агрегированных данных

- **Описание:**  
  Триггеры на таблицах `WorkItem` и `Works` для автоматического обновления кэшированных значений или кэш-таблиц при изменении данных.

- **Недостатки и последствия:**  
  - **Увеличение времени выполнения DML-операций:** Триггеры добавляют дополнительную нагрузку на вставки, обновления и удаления, что особенно критично при больших объемах данных.  
  - **Блокировки и конкуренция:** Триггеры могут приводить к блокировкам и снижать параллелизм.  
  - **Сложность отладки и сопровождения:** Логика триггеров часто скрыта, что усложняет диагностику проблем и тестирование.

---

### 4. Создание или модификация хранимых процедур и функций

- **Описание:**  
  Переписать функцию получения списка заказов на хранимую процедуру с использованием `OUTER APPLY` и inline table-valued функций для подсчёта элементов, что позволит оптимизатору создавать более эффективные планы выполнения.

- **Недостатки и последствия:**  
  - **Повышение сложности кода:** Более сложные процедуры сложнее читать и поддерживать.  
  - **Потенциальные проблемы с совместимостью:** Изменения могут потребовать обновления клиентского кода, если меняется интерфейс вызова.  
  - **Необходимость тестирования:** Требуется тщательное тестирование, чтобы избежать регрессий и ошибок.

---

## Итог

Хотя создание новых таблиц, столбцов, триггеров и сложных процедур может значительно ускорить выборку данных и снизить время выполнения запросов, эти изменения:

- Увеличивают сложность архитектуры и поддержки базы данных.  
- Могут привести к рассинхронизации данных и ошибкам, если не обеспечить надежные механизмы синхронизации.  
- Увеличивают нагрузку на операции записи и обновления.  
- Требуют дополнительного тестирования и контроля качества.  

Поэтому такие изменения должны внедряться только после тщательного анализа, тестирования и оценки компромиссов между производительностью и сложностью поддержки.


# Результаты измерений с помощью SET STATISTICS TIME
## Изначальная скорость выполнения:
**Первый запуск**
Время синтаксического анализа и компиляции SQL Server: 
 время ЦП = 0 мс, истекшее время = 0 мс.

(затронуто строк: 3000)

 Время работы SQL Server:
   Время ЦП = 10083 мс, затраченное время = 10569 мс.
Время синтаксического анализа и компиляции SQL Server: 
 время ЦП = 0 мс, истекшее время = 0 мс.

Время выполнения: 2025-04-24T12:07:32.7152506+03:00

**Второй запуск**

Время синтаксического анализа и компиляции SQL Server: 
 время ЦП = 0 мс, истекшее время = 0 мс.

(затронуто строк: 3000)

 Время работы SQL Server:
   Время ЦП = 9492 мс, затраченное время = 10018 мс.
Время синтаксического анализа и компиляции SQL Server: 
 время ЦП = 0 мс, истекшее время = 0 мс.

Время выполнения: 2025-04-24T12:08:30.6846509+03:00

**Третий запуск**
Время синтаксического анализа и компиляции SQL Server: 
 время ЦП = 0 мс, истекшее время = 0 мс.

(затронуто строк: 3000)

 Время работы SQL Server:
   Время ЦП = 8188 мс, затраченное время = 10212 мс.
Время синтаксического анализа и компиляции SQL Server: 
 время ЦП = 0 мс, истекшее время = 0 мс.

Время выполнения: 2025-04-24T12:09:04.9511777+03:00

## После выполнения оптимизации в Задаче 2
**Первый запуск**
Время синтаксического анализа и компиляции SQL Server: 
 время ЦП = 0 мс, истекшее время = 0 мс.

(затронуто строк: 3000)

 Время работы SQL Server:
   Время ЦП = 1705 мс, затраченное время = 2166 мс.
Время синтаксического анализа и компиляции SQL Server: 
 время ЦП = 0 мс, истекшее время = 4 мс.

Время выполнения: 2025-04-24T11:56:48.2955136+03:00

**Второй запуск**
Время синтаксического анализа и компиляции SQL Server: 
 время ЦП = 0 мс, истекшее время = 0 мс.

(затронуто строк: 3000)

 Время работы SQL Server:
   Время ЦП = 1757 мс, затраченное время = 2144 мс.
Время синтаксического анализа и компиляции SQL Server: 
 время ЦП = 0 мс, истекшее время = 0 мс.

Время выполнения: 2025-04-24T12:09:29.6127291+03:00

**Третий запуск**
Время синтаксического анализа и компиляции SQL Server: 
 время ЦП = 0 мс, истекшее время = 0 мс.

(затронуто строк: 3000)

 Время работы SQL Server:
   Время ЦП = 1672 мс, затраченное время = 2148 мс.
Время синтаксического анализа и компиляции SQL Server: 
 время ЦП = 0 мс, истекшее время = 0 мс.

Время выполнения: 2025-04-24T12:10:01.9236655+03:00

# Использование LLM

* Для описания структуры базы данных и функций использовался DeepSeek.
* Для генерации тестовых данных были предоставлены скрипт для создания объектов базы данных и описание количества необходимых записей из Задачи 2.
* DeepSeek, так же как и ChatGPT, достойных результатов не показал. Либо у меня не получилось правильно их использовать. Вылезали ошибки при использовании предоставленных скриптов, которые дополнительными промптами исправить не получилось.
* После долгих попыток исправить скрипты вышеупомянутых LLM моделей, предоставил данное задание Perplexity с такими же вводными данными и сразу получил рабочее решение без дополнительных уточнений.
* Для выполнения Задачи 2 и Задачи 3 так же использовался Perplexity в силу его предыдущего успеха.
* Изменения по Задаче 2, которые предлагал Perplexity, не отрабатывали сразу должным образом изначально. Но дополнительным промотом решилась эта проблема (нужно было просто удалить существующие функции).
* В процессе получения ответов задавались дополнительные вопросы для собственного понимания оправданности предлагаемой оптимизации.